# TM and TE waves in a circular waveguide

Comprehensive study of TM and TE modes in circular waveguides with theory, equations, and Python programs to compute cutoff frequencies, generate dispersion diagrams, and plot electromagnetic field patterns.

This repository includes:
- Python programs to compute Bessel roots, cutoff frequencies and dispersion curves (scripts/).
- Plot scripts that generate field pattern images (Ez for TM, Hz for TE) and dispersion diagrams.
- Example images (generated by the scripts) stored in `images/` (sample SVGs have been added).
- A concise explanation of theory and usage instructions so students and RF engineers can reproduce the figures.

Preview sample images (committed to the repo):

- TM01 field (Ez) — sample SVG committed and embedded below

![TM01 field](images/tm_0_1_field.svg)

- TE11 field (Hz) — sample SVG committed and embedded below

![TE11 field](images/te_1_1_field.svg)

- Dispersion diagram — sample SVG committed and embedded below

![Dispersion diagram](images/dispersion_diagram.svg)

---

Table of contents
- About
- Theory (short)
- Files in this repo
- Requirements
- Quick start: Generate plots and figures
- Examples
- How the programs work (brief)
- Contributing
- License

About
-----
This project demonstrates TM and TE modes in an ideal circular waveguide of radius a. The included scripts compute modal cutoff frequencies using Bessel function roots, plot dispersion diagrams, and render cross-sectional field patterns for selected modes.

Theory (short)
--------------
- For a circular waveguide of radius a, the transverse wavenumber kc is determined by zeros of Bessel functions:
  - TM modes (Ez != 0): kc = x_mn / a, where x_mn is the nth zero of Jm (Bessel function of first kind).
  - TE modes (Hz != 0): kc = x'_mn / a, where x'_mn is the nth zero of the derivative Jm'(x).
- Cutoff angular frequency:
  - omega_c = c * kc / sqrt(ε_r * μ_r)
- Cutoff frequency (Hz):
  - f_c = c * kc / (2π sqrt(ε_r μ_r))
- Propagation constant (axial):
  - beta(ω) = sqrt((ω^2 μ ε) - kc^2) (real for propagating modes, imaginary for evanescent)

Files in this repo
------------------
- README.md (this file)
- scripts/compute_modes.py — compute and print or save modal zeros and cutoff frequencies
- scripts/plot_dispersion.py — plot dispersion diagram for selected modes and save image
- scripts/plot_fields.py — render cross-sectional field patterns and save images
- requirements.txt — Python dependencies
- images/ (directory for generated SVG/PNGs). Sample files added:
  - images/tm_0_1_field.svg
  - images/te_1_1_field.svg
  - images/dispersion_diagram.svg

Requirements
------------
- Python 3.9+
- numpy
- scipy
- matplotlib

Install (recommended in a virtual environment)
```bash
python -m venv .venv
source .venv/bin/activate   # Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

Quick start: Generate plots and figures
--------------------------------------
1. Compute modes and cutoff frequencies (example: radius a = 0.02 m, relative permittivity = 1)
```bash
python scripts/compute_modes.py --radius 0.02 --modes 3 --zeros 3 --epsilon_r 1 --mu_r 1 --save csv --out results/modes_a0.02.csv
```
2. Generate dispersion diagram (saves images/dispersion_diagram.png)
```bash
python scripts/plot_dispersion.py --radius 0.02 --modes "TM:0-2,TE:1-2" --f_min 0.5e9 --f_max 20e9 --epsilon_r 1 --mu_r 1 --out images/dispersion_diagram.png
```
3. Plot field patterns (e.g., TM01 and TE11)
```bash
python scripts/plot_fields.py --radius 0.02 --mode TM 0 1 --out images/tm_0_1_field.png
python scripts/plot_fields.py --radius 0.02 --mode TE 1 1 --out images/te_1_1_field.png
```

Examples
--------
Below are the embedded sample images now present in the repository.

![TM01 field](images/tm_0_1_field.svg)

![TE11 field](images/te_1_1_field.svg)

![Dispersion diagram](images/dispersion_diagram.svg)

How the programs work (brief)
-----------------------------
- compute_modes.py
  - Uses scipy.special.jn_zeros and jnp_zeros to find Bessel function roots for TM (Jm) and TE (Jm' derivative) modes respectively.
  - Converts roots to kc, then to cutoff frequencies and wavelengths.
  - Outputs a human-readable table and can save CSV.

- plot_dispersion.py
  - For each requested mode, calculates the modal cutoff kc and computes beta over a frequency sweep.
  - Plots beta/k0 (or beta) vs frequency and highlights cutoff.
  - Saves PNG figures.

- plot_fields.py
  - Builds a Cartesian grid, converts to polar coordinates (r, theta).
  - Evaluates the axial field (Ez for TM, Hz for TE) as Jm(kc * r) * angular dependence (cos(m theta) or sin).
  - Normalizes and plots a filled contour with the waveguide circle boundary.

Contributing
------------
Contributions, corrections, or requests for additional features (e.g., lossy walls, dielectric-filled waveguides, 3D visualizations) are welcome. Please open an issue describing the change you'd like to propose or submit a pull request with suggested code and documentation updates.

License
-------
MIT

Conclusion
----------
This project investigates TM and TE mode propagation in a circular waveguide and provides tools to compute modal roots, cutoff frequencies, dispersion curves, and field cross-sections.

Key takeaways:
- Modal cutoff frequencies are determined by Bessel function zeros and their derivatives; the radius and material parameters (ε_r, μ_r) set the absolute cutoff values.
- Below cutoff a mode is evanescent (imaginary beta); above cutoff it propagates (real beta) and its dispersion approaches the light line at high frequency.
- The scripts included here are intended for teaching, demonstration, and preliminary design — they are easy to extend for lossy walls, dielectric fillings, or more modes.

Limitations
- The model assumes an ideal, perfectly conducting circular waveguide, homogeneous filling (or vacuum), and neglects surface roughness and wall losses.
- Numerical accuracy of zeros is governed by SciPy routines; for very high-order zeros or extremely tight tolerances, additional checks may be necessary.
- The interactive examples use a finite frequency window chosen for clarity; adapt the window for your application.

Future work
- Add lossy boundary conditions and conductor models.
- Support dielectric-filled coaxial or multilayered waveguides.
- Add 3D time-domain visualizations and exportable animations.
- Add unit tests and CI to validate numerical outputs across SciPy versions.

Real-time example
-----------------
Below is a self-contained interactive example you can save as `scripts/interactive_dispersion.py`. It computes TM/TE cutoff frequencies using SciPy Bessel zeros and provides interactive controls to inspect dispersion (beta/k0) vs frequency for selected modes and radius in real time.

Save this file as scripts/interactive_dispersion.py and run:
```bash
python scripts/interactive_dispersion.py
```

```python
#!/usr/bin/env python3
"""
Interactive dispersion viewer for circular waveguide TM/TE modes.

Saves: scripts/interactive_dispersion.py
Requires: numpy, scipy, matplotlib
"""
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, RadioButtons
from scipy import special

# Physical constants
c = 299792458.0
eps0 = 8.8541878128e-12
mu0 = 4*np.pi*1e-7

# Default parameters
a0 = 0.02        # radius (m)
eps_r0 = 1.0
mu_r0 = 1.0

# Precompute a few Bessel zeros for m=0..3, n=1..6 (adjust as needed)
max_m = 3
n_zeros = 6
jn = {}
jnp = {}
for m in range(max_m+1):
    jn[m] = special.jn_zeros(m, n_zeros)        # zeros of Jm (TM)
    jnp[m] = special.jnp_zeros(m, n_zeros)      # zeros of Jm' (TE)

def cutoff_freq(mode_type, m, n, a, eps_r=1.0, mu_r=1.0):
    """Return cutoff frequency (Hz) for given mode_type ('TM' or 'TE'), order m, zero index n (1-based)."""
    if mode_type == 'TM':
        x = jn[m][n-1]
    else:
        x = jnp[m][n-1]
    kc = x / a
    fc = c * kc / (2*np.pi * np.sqrt(eps_r * mu_r))
    return fc, kc

def dispersion_vs_freq(mode_type, m, n, a, f_array, eps_r=1.0, mu_r=1.0):
    """Compute beta/k0 (normalized propagation constant) vs frequency array."""
    fc, kc = cutoff_freq(mode_type, m, n, a, eps_r, mu_r)
    omega = 2*np.pi*f_array
    k0 = 2*np.pi*f_array / c * np.sqrt(eps_r * mu_r)
    beta = np.sqrt(np.maximum(0.0, k0**2 - kc**2))  # real part for propagating
    # for evanescent frequencies (k0<kc) show imaginary beta as negative imaginary magnitude
    evanescent = k0 < kc
    beta_norm = np.where(evanescent, -np.sqrt(kc**2 - k0**2)/k0, beta/k0)
    return beta_norm, fc

# Frequency sweep
fmin = 0.01e9
fmax = 20e9
f = np.linspace(fmin, fmax, 800)

# Initial plot parameters
mode_type = 'TM'
m_init = 0
n_init = 1
a = a0

beta_norm, fc_init = dispersion_vs_freq(mode_type, m_init, n_init, a, f, eps_r0, mu_r0)

fig, ax = plt.subplots(figsize=(8,5))
plt.subplots_adjust(left=0.15, bottom=0.28)
line, = ax.plot(f/1e9, beta_norm, lw=2)
ax.axvline(fc_init/1e9, color='gray', linestyle='--', label='cutoff')
ax.set_xlabel('Frequency (GHz)')
ax.set_ylabel('Normalized beta (beta/k0); negative => evanescent')
ax.set_title(f'{mode_type}{m_init}{n_init} dispersion (a={a:.3f} m)')
ax.grid(True)
ax.set_ylim(-1.2, 1.2)
ax.legend()

# Slider: radius
ax_a = plt.axes([0.15, 0.16, 0.7, 0.03])
slider_a = Slider(ax_a, 'Radius (m)', 0.005, 0.1, valinit=a0, valstep=0.001)

# Radio buttons: TM/TE
ax_rt = plt.axes([0.02, 0.5, 0.1, 0.15])
radio_mode = RadioButtons(ax_rt, ('TM', 'TE'), active=0)

# Slider: m
ax_m = plt.axes([0.15, 0.10, 0.3, 0.03])
slider_m = Slider(ax_m, 'm', 0, max_m, valinit=m_init, valstep=1)

# Slider: n
ax_n = plt.axes([0.55, 0.10, 0.3, 0.03])
slider_n = Slider(ax_n, 'n (1-based)', 1, n_zeros, valinit=n_init, valstep=1)

def update(val=None):
    mode = radio_mode.value_selected
    m_val = int(slider_m.val)
    n_val = int(slider_n.val)
    a_val = slider_a.val
    beta_norm, fc = dispersion_vs_freq(mode, m_val, n_val, a_val, f, eps_r0, mu_r0)
    line.set_ydata(beta_norm)
    ax.set_title(f'{mode}{m_val}{n_val} dispersion (a={a_val:.3f} m)')
    # update cutoff line
    # remove previous verticals and re-add
    [ln.remove() for ln in ax.lines[1:]]  # keep the main plot (index 0)
    ax.axvline(fc/1e9, color='gray', linestyle='--', label=f'cutoff = {fc/1e9:.3f} GHz')
    ax.relim()
    ax.autoscale_view()
    fig.canvas.draw_idle()

slider_a.on_changed(update)
slider_m.on_changed(update)
slider_n.on_changed(update)
radio_mode.on_clicked(update)

plt.show()